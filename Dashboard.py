import streamlit as st
import os
import pymongo
import pandas as pd
import plotly.express as px
from datetime import datetime

st.set_page_config(page_title="CVEs", page_icon="ðŸ“ˆ", layout="wide")

@st.cache_resource
def init_connection():
    return pymongo.MongoClient(os.environ['MONGO_URI'])

client=init_connection()
cve_collection = client.cve_storage.cves
vendor_collection = client.cve_storage.vendors
current_year = datetime.now().year

def generateRecent(vendor = {'status': 'Analyzed'}):
    last_10_records = cve_collection.find(vendor, {'id':1, 'description':1, '_id': 0, 'cvss': 1, 'epss': 1}).sort('_id', -1).limit(10)
    df = pd.DataFrame(list(last_10_records))
    return df

def generateVendorRecent(vendor):
    query = {'vendors': { "$elemMatch": { "$eq": vendor }}}
    last_10_records = cve_collection.find(query, {'id':1, 'description':1, '_id': 0, 'cvss': 1, 'epss': 1}).sort('_id', -1).limit(10)
    df = pd.DataFrame(list(last_10_records))
    return df

def countDocuments():
    total_count = cve_collection.count_documents({})
    return str(total_count)

def countVendors():
    total_count = len(cve_collection.distinct('vendors'))
    return str(total_count)

def getVendorList():
    vendorList = []
    result = vendor_collection.find({}, {"vendor": 1, "_id": 0})
    for i in result:
        vendorList.append(i['vendor'])
    return sorted(vendorList)

def getFiltered(vendor):
    pipeline = [
    {
        "$match": {
            "published": {
                "$gt": datetime(current_year, 1, 1, 0, 0, 0)
            },
            "vendors": {
                "$elemMatch": {
                    "$eq": vendor
                }
            }
        }
    },
    {
        "$unwind": "$products"
    },
    {
        "$group": {
            "_id": "$products",
            "count": {"$sum": 1}
        }
    },
    {
        "$sort": {"count": -1}
    },
    {
        "$limit": 10
    }
    ]
    result = cve_collection.aggregate(pipeline)
    data = []
    for vendor in result:
        data.append([vendor['_id'], vendor['count']])
    df = pd.DataFrame(data, columns=['Product', 'CVEs'])
    df = df.sort_values(by='CVEs', ascending=True)
    fig = px.bar(df, x='CVEs', y = 'Product', orientation= 'h')
    return fig

def getVendors(mode):
    pipeline = [
    {
        "$match": {
            "published": {
                "$gt": datetime(current_year, 1, 1, 0, 0, 0)
            },
            "vendors": {
                    "$ne": ""
            }
        }
    },
    {
        "$unwind": "$vendors"
    },
    {
        "$group": {
            "_id": "$vendors",
            "count": {"$sum": 1}
        }
    },
    {
        "$sort": {"count": -1}
    },
    {
        "$limit": 10
    }
    ]
    result = cve_collection.aggregate(pipeline)
    data = []
    for vendor in result:
        data.append([vendor['_id'], vendor['count']])
    if mode == 'list':
        text_elements = [item[0] for item in data]
        return text_elements
    elif mode == 'graph':
        df = pd.DataFrame(data, columns=['Vendor', 'CVEs'])
        df = df.sort_values(by='CVEs', ascending=True)
        fig = px.bar(df, x='CVEs', y = 'Vendor', orientation= 'h')
        return fig

def generateStatsbyYear(vendor):
    monthlist = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    values = []
    pipeline = [
    {
        "$match": {
            "published": {
                "$gt": datetime(current_year, 1, 1, 0, 0, 0)
            },
            "vendors": {
                "$elemMatch": {
                    "$eq": vendor
                }
            }
        }

    },
    {
        "$group": {
            "_id": {"month": {"$month": "$published"}},
            "count": {"$sum": 1}
        }
    },
    {
        "$sort": {"_id.month": 1}
    }
    ]
    result = cve_collection.aggregate(pipeline)
    
    count = 0
    for doc in result:
        values.append(doc['count'])
        #print(doc['count'])
        count += 1

def getProducts(vendor):
    result = vendor_collection.find_one({"vendor": vendor}, {"products": 1, "_id": 0})
    return result['products']

def generateStatsbyYear():
    monthlist = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    values = []
    pipeline = [
    {
        "$match": {
            "published": {
                "$gt": datetime(current_year, 1, 1, 0, 0, 0)
            }
        }
    },
    {
        "$group": {
            "_id": {"month": {"$month": "$published"}},
            "count": {"$sum": 1}
        }
    },
    {
        "$sort": {"_id.month": 1}
    }
    ]
    result = cve_collection.aggregate(pipeline)
    
    count = 0
    for doc in result:
        values.append(doc['count'])
        #print(doc['count'])
        count += 1


    df = pd.DataFrame({
    'Month': monthlist[:count],
    'CVE Count': values
    })
    df['Month'] = pd.Categorical(df['Month'], categories=monthlist, ordered=True)
    chart = px.line(df, x='Month', y= 'CVE Count', text='CVE Count')
    chart.update_traces(textposition="top center")
   # print(chart_data)
    return chart

def generateFilteredStatsbyYear(vendor):
    monthlist = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    values = []
    pipeline = [
    {
        "$match": {
            "published": {
                "$gt": datetime(current_year, 1, 1, 0, 0, 0)
            },
            "vendors": {
                "$elemMatch": {
                    "$eq": vendor
                }
            }
        }

    },
    {
        "$group": {
            "_id": {"month": {"$month": "$published"}},
            "count": {"$sum": 1}
        }
    },
    {
        "$sort": {"_id.month": 1}
    }
    ]
    result = cve_collection.aggregate(pipeline)
    
    count = 0
    for doc in result:
        values.append(doc['count'])
        #print(doc['count'])
        count += 1

    df = pd.DataFrame({
    'Month': monthlist[:count],
    'CVE Count': values
    })
    df['Month'] = pd.Categorical(df['Month'], categories=monthlist, ordered=True)
    chart = px.line(df, x='Month', y= 'CVE Count', text='CVE Count')
    chart.update_traces(textposition="top center")
   # print(chart_data)
    return chart

st.markdown("# CVE Dashboard")
st.sidebar.header("CVE Statistics")
st.sidebar.write("CVEs in database: " + countDocuments())
st.sidebar.write("Unique vendors: " + countVendors())
st.sidebar.write("Data collected from FIRST and NVD")

firstinput, secondinput = st.columns([0.5,0.5], vertical_alignment='bottom')
vendoroption = firstinput.selectbox("Vendor", getVendorList(),index=None)

col1, col2 = st.columns([0.5, 0.5])
if vendoroption is not None:
    col1.subheader(f"Top Product CVEs for {vendoroption} in {current_year}")
    col1.write(getFiltered(vendoroption))
    col2.subheader(f"CVEs published in {current_year}")
    col2.write(generateFilteredStatsbyYear(vendoroption))
    st.subheader("Most Recent Vulnerabilities for " + vendoroption)
    config = {'id': st.column_config.TextColumn('CVE ID'), 'cvss': st.column_config.TextColumn('CVSS Score'), 'description': st.column_config.TextColumn('Description'), 'epss': st.column_config.TextColumn('EPSS Score')}
    st.dataframe(generateVendorRecent(vendoroption), column_config = config, hide_index = True, use_container_width=True)

else:
    col1.subheader(f"Top Vendor CVEs in {current_year}")
    col1.write(getVendors('graph'))
    col2.subheader(f"CVEs published in {current_year}")
    col2.write(generateStatsbyYear())
    st.subheader("Most Recent Vulnerabilities")
    config = {'id': st.column_config.TextColumn('CVE ID'), 'cvss': st.column_config.TextColumn('CVSS Score'), 'description': st.column_config.TextColumn('Description'), 'epss': st.column_config.TextColumn('EPSS Score')}
    st.dataframe(generateRecent(), column_config = config, hide_index = True, use_container_width=True)



# Streamlit widgets automatically run the script from top to bottom. Since
# this button is not connected to any other logic, it just causes a plain
# rerun.
st.button("Re-run")
