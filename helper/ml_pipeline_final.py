
import pandas as pd  # Data manipulation and analysis library
import numpy as np  # Numerical computing library

# Time series analysis libraries
from statsmodels.tsa.statespace.sarimax import SARIMAX  # Seasonal AutoRegressive Integrated Moving Average with eXogenous regressors model
from sklearn.model_selection import ParameterGrid  # Class for generating all possible combinations of hyperparameters

# Model evaluation metrics
from sklearn.metrics import mean_squared_error

import pymongo
from datetime import datetime
from scipy import stats
import os

client = pymongo.MongoClient(os.environ['MONGO_URI'])
cve = client.cvedb.cves

pipeline = [
    {
        '$match': {
            'published': {'$gt': datetime(2018, 12, 1)},
            'status': {'$ne': 'Rejected'},
            'description': {'$not': {'$regex': '^Reject', '$options': 'i'}}
        }
    },
    {
        '$group': {
            '_id': {
                'year': {'$year': '$published'},
                'month': {'$month': '$published'}
            },
            'count': {'$sum': 1},
        }
    },
    {
        '$addFields': {
            'date': {
                '$dateFromParts': {
                    'year': '$_id.year',
                    'month': '$_id.month'
                }
            }
        }
    },
    {
        '$sort': {
            '_id.year': 1,
            '_id.month': 1
        }
    }
]

result = list(cve.aggregate(pipeline))
recordsdict = {'Month': [], 'Count': []}
for record in result:
    recordsdict['Month'].append(record['date'])
    recordsdict['Count'].append(record['count'])

df = pd.DataFrame(recordsdict)
df['Month'] = df['Month'].dt.to_period("M")
df['Month'] = df['Month'].astype('datetime64[ns]')
df = df[:-1]
print(df.tail())
#print(df)
print(df['Count'].describe())

## Outlier Handling
zscore = np.abs(stats.zscore(df['Count']))
outlier_threshold = 3
rolling = df['Count'].rolling(window=6, min_periods = 1).median()
df_outlier = df
df_outlier['Count'] = np.where(zscore < outlier_threshold, df['Count'], rolling)
print(df_outlier.tail())
print(df_outlier['Count'].describe())

train_months = 60
test_months = 6
future_months = 6
train_data = df_outlier.head(train_months)
#print(train_data.head(train_months))

test_data = df_outlier.iloc[train_months: train_months + test_months]
#print(test_data)

best_params = None
second_best_params = None
best_rmse = np.inf
best_model = None

# param_grid = {
#     'order': [(2, 1, 1), (3, 1, 2), (2, 2, 2), (3, 1, 3)],
#     'seasonal_order': [(1, 1, 1, 12), (1, 1, 2, 12), (2, 1, 2, 12), (1, 1, 1, 12)],
#     'trend': ['n', 'c', 't', 'ct'],
#     'enforce_stationarity': [True, False],
#     'enforce_invertibility': [True, False],
# }


# for params in ParameterGrid(param_grid):
#     model = SARIMAX(train_data['Count'], **params)
#     model_fit = model.fit(method='powell', maxiter=5000)
#     # Predictions for the test set
#     predictions_test = model_fit.predict(start=test_data.index[0], end=test_data.index[-1])
#     # Calculate metrics for the test set
#     actual_values_test = test_data['Count']
#     rmse_test = np.sqrt(mean_squared_error(actual_values_test, predictions_test))
#     print(f"CURRENT RMSE: {rmse_test:.2f}")

#     if rmse_test < best_rmse:
#       best_rmse = rmse_test
#       best_model = model_fit
#       second_best_params = best_params
#       best_params = params

# print(f"BEST PARAMETERS: {best_params}")
# print(f"Best RMSE {best_rmse}")

params = {'enforce_invertibility': False, 'enforce_stationarity': False, 'order': (2, 2, 2), 'seasonal_order': (2, 1, 2, 12), 'trend': 'ct'}
model = SARIMAX(train_data['Count'], **params)
model_fit = model.fit(method='powell', maxiter=5000)

predictions_test = model_fit.predict(start=test_data.index[0], end=test_data.index[-1])

actual_values_test = test_data['Count']
rmse_test = np.sqrt(mean_squared_error(actual_values_test, predictions_test))
print(f"CURRENT RMSE: {rmse_test:.2f}")

model = SARIMAX(df_outlier['Count'], **params)
model_fit = model.fit(method='powell', maxiter=5000)

last_date = df['Month'].max()
next_month_first_day = last_date + pd.DateOffset(months=1)
next_month_first_day = next_month_first_day.replace(day=1)

future_index = pd.date_range(start=next_month_first_day, periods=future_months, freq='MS')
forecast = model_fit.get_forecast(steps=future_months)
future_predictions = forecast.predicted_mean

confidence_df = forecast.conf_int()
print(confidence_df)

future_predictions_df = pd.DataFrame(data={'Month': future_index, 'Count': future_predictions.values}, index=range(60, 60 + future_months))
print(future_predictions_df)