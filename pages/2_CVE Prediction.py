
import pandas as pd  # Data manipulation and analysis library
import plotly.graph_objects as go
# Time series analysis libraries
from statsmodels.tsa.statespace.sarimax import SARIMAX  # Seasonal AutoRegressive Integrated Moving Average with eXogenous regressors model

# Model evaluation metrics
from sklearn.metrics import mean_squared_error

import pymongo
from datetime import datetime

import streamlit as st
import pymongo
import pandas as pd
import numpy as np
from scipy import stats

import os

st.set_page_config(page_title="CVEs", layout="wide")

@st.cache_resource
def init_connection():
    return pymongo.MongoClient(os.environ['MONGO_URI'])

client = init_connection()
cve = client.cve_storage.cves


def retrieve_documents(year, month):
    pipeline = [
        {
            '$match': {
                'published': {'$gt': datetime(year, month, 1)},
                'status': {'$ne': 'Rejected'},
                'description': {'$not': {'$regex': '^Reject', '$options': 'i'}}
            }
        },
        {
            '$group': {
                '_id': {
                    'year': {'$year': '$published'},
                    'month': {'$month': '$published'}
                },
                'count': {'$sum': 1},
            }
        },
        {
            '$addFields': {
                'date': {
                    '$dateFromParts': {
                        'year': '$_id.year',
                        'month': '$_id.month'
                    }
                }
            }
        },
        {
            '$sort': {
                '_id.year': 1,
                '_id.month': 1
            }
        }
    ]
    result = list(cve.aggregate(pipeline))
    recordsdict = {'Month': [], 'Count': []}
    for record in result:
        recordsdict['Month'].append(record['date'])
        recordsdict['Count'].append(record['count'])

    df = pd.DataFrame(recordsdict)
    df['Month'] = df['Month'].dt.to_period("M")
    df['Month'] = df['Month'].astype('datetime64[ns]')
    print("OLD DF")
    print(df)
    df = df[:-1]
    print(df['Count'].describe())
    
    return df

def predictor(df):

    ## Outlier Handling
    zscore = np.abs(stats.zscore(df['Count']))
    outlier_threshold = 3
    df_outlier = df
    rolling = df_outlier['Count'].rolling(window=6, min_periods = 1).median()
    df_outlier['Count'] = np.where(zscore < outlier_threshold, df_outlier['Count'], rolling)
#    print(df_outlier.tail())
#    print(df_outlier['Count'].describe())

    train_months = 60
    test_months = 6
    future_months = 6

    train_data = df_outlier.head(train_months)
    test_data = df_outlier.iloc[train_months: train_months + test_months]

    params = {'enforce_invertibility': False, 'enforce_stationarity': False, 'order': (2, 2, 2), 'seasonal_order': (2, 1, 2, 12), 'trend': 'ct'}
    model = SARIMAX(train_data['Count'], **params)
    model_fit = model.fit(method='powell', maxiter=5000)

    predictions_test = model_fit.predict(start=test_data.index[0], end=test_data.index[-1])

    actual_values_test = test_data['Count']
    rmse_test = np.sqrt(mean_squared_error(actual_values_test, predictions_test))
    print(f"CURRENT RMSE: {rmse_test:.2f}")

    model = SARIMAX(df_outlier['Count'], **params)
    model_fit = model.fit(method='powell', maxiter=5000)

    last_date = df_outlier['Month'].max()
#    print(f"LAST DATE: {last_date}")
    next_month_first_day = last_date + pd.DateOffset(months=1)
    next_month_first_day = next_month_first_day.replace(day=1)

    future_index = pd.date_range(start=next_month_first_day, periods=future_months, freq='MS')
    forecast = model_fit.get_forecast(steps=future_months)
    future_predictions = forecast.predicted_mean

    confidence_df = forecast.conf_int(alpha=0.1)
    confidence_df = confidence_df.reset_index()
#    print(confidence_df)
    
    future_predictions_df = pd.DataFrame(data={'Month': future_index, 'Count': future_predictions.values}, index=range(60, 60 + future_months))
    future_predictions_df = future_predictions_df.reset_index()
    combined_df = pd.concat([future_predictions_df, confidence_df], axis=1)
    print(combined_df)
    
    return combined_df

def calculate_time(years=5):
    months = ((years * 12) + 6 + 1) # + 1 would be to cover the dropped month and 6 months for RMSE calculation
    current_date = datetime.now()
    date_ago = current_date - pd.DateOffset(months=months)
#    print(f"YEAR: {date_ago.year}, MONTH {date_ago.month}")
    return date_ago.year, date_ago.month


fig = go.Figure()

year, month = calculate_time()
retrieved_df = retrieve_documents(year, month)
predicted_df = predictor(retrieved_df.copy())
#print("RETRIEVED DF \n")
#print(retrieved_df)
retrieved_df['Month'] = retrieved_df['Month'].dt.to_period("M").astype(str)
#print(df['Month'])
retrieved_df = retrieved_df[36:]
# Add a solid line for historical data
fig.add_trace(go.Scatter(
    x=retrieved_df['Month'],
    y=retrieved_df['Count'],
    mode='lines+text',
    name='Actual Data',
    line=dict(color='blue', dash='solid'),
    text = retrieved_df['Count'],
    textposition= 'top center'
))
predicted_df['Count'] = predicted_df['Count'].astype(int)

fig.add_trace(go.Scatter(
    x=predicted_df['Month'],
    y=predicted_df['Count'],
    mode='lines+text',
    name='Predicted Data',
    line=dict(color='red', dash='dash'),
    text = predicted_df['Count'],
    textposition= 'top center'  # Dashed line
))

fig.add_trace(go.Scatter(
    x=pd.concat([predicted_df['Month'], predicted_df['Month'][::-1]]),  # Reversed order of months
    y=pd.concat([predicted_df['upper Count'], predicted_df['lower Count'][::-1]]),  # Reversed order of lower bounds
    fill='toself',
    fillcolor='rgba(0, 100, 80, 0.3)',
    line=dict(color='rgba(255, 255, 255, 0)'),
    hoverinfo="skip",
    showlegend=False,
    name='Confidence Interval'
))

st.markdown("# Projected CVE Reports")
st.write("Disclaimer: The predicted figures may change and may be inaccurate due to the nature of vulnerability reports.")
st.plotly_chart(fig)